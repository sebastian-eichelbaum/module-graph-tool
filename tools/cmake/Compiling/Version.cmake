# Generate a version info header that also contains the git version hash. It can be included in your code. You have to
# add the target "project_version" to your targets to ensure automatic updates.

# Keep the directory of THIS file. If we would use CMAKE_CURRENT_LIST_DIR in a function, it contains the dir of the
# calling CMake file.
set(CURRENT_LIST_DIR ${CMAKE_CURRENT_LIST_DIR})

# When this script is called by the target "version_update" as an external script, we require out_dir to be set to the
# binary (generated) dirs. These values are known during the usual cmake run.
if(NOT DEFINED out_dir)
    set(out_dir "${CMAKE_CURRENT_BINARY_DIR}/nx_app_generated")
endif()

# The names of the generated files. Be aware that the ${out_dir} is added to the include path. Ensure the filenames are
# somewhat unique (not like 'version.h') to avoid clashes with the users own version files.
set(version_input_file "${out_dir}/nx_app_version.h.in")
set(version_generated_file "${out_dir}/nx/app/generated_version.h")
set(version_git_state_file "${out_dir}/nx_app_git_state.txt")

# Get the current git log hash/version info and update the generated version header if there is a change since last run.
function(version_git_update)
    # Get the latest abbreviated commit hash of the working branch
    execute_process(
        COMMAND git log -1 --format=%h
        WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
        OUTPUT_VARIABLE GIT_HASH
        OUTPUT_STRIP_TRAILING_WHITESPACE
    )

    # Load the previous git hash
    if(EXISTS ${version_git_state_file})
        file(STRINGS ${version_git_state_file} CONTENT)
        list(GET CONTENT 0 GIT_HASH_CACHE)
    endif()
    if(NOT DEFINED GIT_HASH_CACHE)
        set(GIT_HASH_CACHE "INVALID")
    endif()

    # Only generate the version.h.in if the hash has changed. This will prevent us from rebuilding the project more than
    # we need to. Also force a run whenever cmake calls this during (re-)configuration.
    if(NOT ${GIT_HASH} STREQUAL ${GIT_HASH_CACHE}
       OR NOT EXISTS ${version_generated_file}
       OR NOT RUN_VERSION_GIT_UPDATE
    )
        # Store the current hash for later
        file(WRITE ${version_git_state_file} ${GIT_HASH})

        # If the has has changed, we also query the branch and timestamp
        execute_process(
            COMMAND git branch --show-current
            WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
            OUTPUT_VARIABLE GIT_BRANCH
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )
        execute_process(
            COMMAND git log -1 --format=%ad --date=unix
            WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
            OUTPUT_VARIABLE GIT_DATE
            OUTPUT_STRIP_TRAILING_WHITESPACE
        )

        # Some version headers use different variable names but always mean the same: this hash.
        set(PROJECT_GITHASH ${GIT_HASH})
        set(PROJECT_GITDATE ${GIT_DATE})
        set(PROJECT_GITBRANCH ${GIT_BRANCH})

        generate_versionh()
        configure_file(${version_input_file} ${version_generated_file})
    endif()
endfunction()

# Setup the project version target. This is done in a function to avoid it being executed by the "version_update"
# target.
function(version_setup)
    # Create a default target to contain all the GIT version target
    if(NOT TARGET project_version)
        add_library(project_version INTERFACE)
    endif()

    # This target calls this script every build:
    add_custom_target(
        version_update
        COMMAND
            ${CMAKE_COMMAND}
            # Pass on the out(generated) dirs
            -Dout_dir=${out_dir}
            # Also pass the previous values that are used in the version file. If we skip this, the version_update call
            # will fill these with empty values
            -DPROJECT_VERSION="${PROJECT_VERSION}" -DPROJECT_AUTHORS="${PROJECT_AUTHORS}"
            -DPROJECT_NAME="${PROJECT_NAME}" -DPROJECT_HOMEPAGE_URL="${PROJECT_HOMEPAGE_URL}"
            -DPROJECT_DESCRIPTION="${PROJECT_DESCRIPTION}"
            # Run this script directly
            -DRUN_VERSION_GIT_UPDATE=1 -P ${CURRENT_LIST_DIR}/Version.cmake
        BYPRODUCTS ${version_generated_file}
    )

    # Include everything
    target_include_directories(project_version INTERFACE ${out_dir})
    add_dependencies(project_version version_update ${version_input_file})

    # This ensure that this is run at least once, even if the user forgets to refer to "project_version" as an interface
    # target
    version_git_update()
endfunction()

# Generates the required version.h.in file.
function(generate_versionh)
    set(VERSIONH_SRC
        [=[// Generated by CMAKE
#define nx_VERSION_NUMERIC "@PROJECT_VERSION@"
#define nx_VERSION_AUTHORS "@PROJECT_AUTHORS@"
#define nx_VERSION_NAME "@PROJECT_NAME@"
#define nx_VERSION_HOMEPAGE "@PROJECT_HOMEPAGE_URL@"
#define nx_VERSION_DESCRIPTION "@PROJECT_DESCRIPTION@"
#define nx_VERSION_HASH "@PROJECT_GITHASH@"
#define nx_VERSION_BRANCH "@PROJECT_GITBRANCH@"
#define nx_VERSION_DATE @PROJECT_GITDATE@
]=]
    )

    if(EXISTS ${version_input_file})
        file(READ ${version_input_file} VERSIONH_CURRENT)
    else()
        set(VERSIONH_CURRENT "")
    endif()

    if(NOT "${VERSIONH_SRC}" STREQUAL "${VERSIONH_CURRENT}")
        file(WRITE ${version_input_file} "${VERSIONH_SRC}")
    endif()
endfunction()

# This is used to run this function from an external cmake process every build.
if(RUN_VERSION_GIT_UPDATE)
    version_git_update()
else()
    version_setup()
endif()
